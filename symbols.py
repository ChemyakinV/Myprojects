import tkinter as tk 				#Для работы с графической частью приложения
import pyperclip					#Для работы с буфетом обмена

root = tk.Tk()						
root.geometry('435x290')
root.title('Symbols')

buttons = {}						#Словарь для хранения позиций и характеристик кнопок
output  =  []						#Необработаный двумерный массив состояний кнопок 
stage2 = []							#Это массив преобразует каждый вложенный список предыдущего элемента в спсиок с одним элементом
stage3 = []							#Этот список преобразует предыдущий в одномерный список
result = []							#Преобразует предыдущий список, в список с одним элементом

class Button():
	def __init__(self, y, x, color):
		'''Создаем кнопку, задаем положение и начальный цвет'''
		self.button = tk.Button(root, width = 2, bg = color , command = lambda: self.check(self.button, y, x, color))	#Создаем кнопку и задаем ей команду при нажатии
		buttons.update({str(y)+str(x): self.button})		#Добавляем кнопку в словарь, с ключем равным координатам

	def check(self, button, y, x, color):
		button.destroy()	#Удаляем переданую в функцию кнопку, чтобы потом создать на ее месте новую с другим цветом

		if (color == '#dadada'):	#Меняем цвет кнопки и ее состояние на противоположное
			color = '#00a03e'
			state = '1'
		else: 
			color = '#dadada'
			state = '0'

		output[y][x+2] = state		#Заменяем состояние кнопки в массиве состояний всех кнопок исходя из координат кнопки

		self.button = tk.Button(root, width = 2, bg = color, command = lambda: self.check(self.button, y, x, color))	#Создаем кнопку с тем же положением,но с другим цветом 
		buttons.update({str(y)+str(x): self.button}) 	#Передобавляем кнопку в словарь с ключем равным координатам
		build()		#Обращаемся к функции отрисовки



for y in range(8):			#Этот блок заполняет словарь кнопок в первый раз
	for x in range(8):
		Button(y, x, '#dadada')

for i in range(8):			#Создаем двумерный массив состояний кнопок
	output.append(list('0b'+'0'*8))		#"0b" -- формат записи последовательности битов, "0*8" -- записываем в каждый подсписок пустую 8-ми битную последовательность

def build():
	'''Функция отрисовки интерфейса программы'''
	for i in buttons:
		'''Берем каждую кнопку из словаря и задаем ей положение и отступ на окне программы'''
		buttons.get(i).grid(row = i[0], column = i[1], padx = 5, pady = 5)

	Labela = tk.Label(root, text = 'Result', width = 20)		#Просто надпись
	text = tk.Text(root, width = 12, height = 10)				#Поле для вывода результатов
	text.insert(3.0, resultshow())								#Добавляем в предыдущее поле текст и указываем размер, resultshow() возвращает нам конечный результат
	btn = tk.Button(root, text = 'Clear', width = 10, bg = 'blue', fg = 'white', command = lambda:clean())		#Кнопка для возвращения к первичному состорянию всех кнопок 
	copybtn = tk.Button(root, text = 'Copy', width = 10, bg = '#54e874', fg = 'white', command = lambda: pyperclip.copy(resultshow()))	#Кнопка для занесения результатов в буфет обмена

	'''Далее идет расстановка, на окне программы, выше указаных элементов меню'''
	Labela.grid(row = 0, column = 8, sticky = tk.S, padx = 5, pady = 5)
	text.grid(row = 1, column = 8, rowspan = 5, sticky = tk.N, padx = 5, pady = 5)
	btn.grid(row = 7, column = 8, padx = 5, pady = 5)
	copybtn.grid(row = 6, column = 8, padx = 5, pady = 5)

def clean():
	'''Функция для возвращения всех кнопок к первичному состоянию'''
	buttons.clear()		#Удаляем содержимое словаря с кнопками для дальнейшего перенаполнения
	output.clear()		#Удаляем содержимое двумерного массив состояний для дальнейшего перенаполнения

	for i in range(8):
		'''Перезаполняем двумерный массив состояний кнопок'''
		output.append(list('0b'+'0'*8))

	'''После удаление содержимого массива с кнопами, заново наполняем его'''
	for x in range(8):
		for y in range(8):
						Button(x, y, '#dadada')
	
	build()		#Стерев все данные копок и создав новые, возвращаемся к функции отрисовки


def resultshow():
	for q in output:
		'''Преобразуем какждый вложеный список списка output в список с одним элементом'''
		stage1 = ''.join(q)			#Тут происходит скелейка элементов вложеного списка
		stage2.append(stage1)		#Добавляем каждый список с одним элементом во второй вспомогательный список

	stage3.append('{')				#Особенности оформления конечного результата
	stage3.append('},')				#Особенности оформления конечного результата

	for e in stage2:
		'''Берем единственый элемент каждого вложенного списка, и добавляем оформление и отступы, после чего добавляем в третий вспомогательный список'''
		stage3.insert(-1, e + ', ')

	result = ''.join(stage3)	#Склеиваем все элементы третьего вспомогательного списка

	'''Удаляем содержимое вспомогательных списков, чтобы избежать ошибок'''
	stage2.clear()
	stage3.clear()

	return result 		#Возвращаем конечный результат

build()		#Первичный запуск программы отрисовки

root.mainloop()